# 这个实验需要注意的点
## 1. 段寄存器的设置
BIOS中断的int 10 对于偏移量是有默认的段的。可以在wiki上看到

> AL = Write mode, BH = Page Number, BL = Color, CX = String length, DH = Row, DL = Column, ES:BP = Offset of string

所以在setup.s里打印信息的时候需要把段置为setup的内存起始


汇编代码的段（segment）作用在于可以扩大寻址范围&分离代码的作用范围。由于8086的段寄存器只有16位所以寻址范围只有2的16次方=64K，所以为了扩大寻址范围使用了cs:ip这种实模式寻址方式。然后对于一些特定的汇编语言里，标号表示的数据在被标号表示偏移的时候使用的都是相对偏移，所以类似于上面的int 10，BP是这个汇编文件汇编成二进制文件之后的相对于开头的偏移距离，而需要配上es这种段寄存器才是真实的物理内存地址。

## 2.打印内存数字需要转换ascii码的数字
打印的时候默认把内存数字作为ascii码点，转换成ascii的对于字符打印在屏幕上。
想要打印成十六进制的模样，就得把内存移到寄存器里，然后用寄存器的ah，al的高四位和低四位的数字（四位二进制等于一位十六进制）加上0x30，而因为ascii0-9和a-f是有7个间隔的，所以如果值加完之后大于0x3a，则需要再加0x7，这里需要使用判断cmp，
```
cmp a,b
jl 
``` 
的意思是a小于b，跳转到jl的数据的位置

## 3.长度大于1字节的数据在内存的打印顺序
一般是小端，所以打印内存`es:[2]`为起始地址，2字节长度的内存数据的时候
2字节，16位，存放到ax寄存器里。
正确的输出顺序是  ah高四位，ah低四位，al高四位，al低四位。


# TODO
把逐个用寄存器打印的愚蠢的代码改成使用栈+循环打印
